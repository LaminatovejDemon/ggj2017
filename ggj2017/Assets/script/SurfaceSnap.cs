using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Component used to snap an object to the surface. 
///
/// <param name="_surface">reference to the existing surface</param>
/// <param name="_width">object width in the X axis, if greater than zero, object will be floating on two points</
/// <param name="_softness">logarithmic interpolation of the floating object to the surface</param>
/// <param name="_rockingAngle">perpendicular floating angle generated by Sin function</param>
/// </summary>
public class SurfaceSnap : MonoBehaviour {

	public Surface _surface;
	public float _width = 0;
	public float _softness = 0.5f;
	public float _rockingAngle = 15.0f;

	Vector3 _leftDepth, _rightDepth;
	Vector3 _targetPosition;

	void Update () {

		Vector3 leftTest_ = transform.position + Vector3.left * _width * 0.5f;
		Vector3 rightTest_ = transform.position + Vector3.right * _width * 0.5f;
		_leftDepth = _surface.GetSurfaceZ (leftTest_);
		_rightDepth = _surface.GetSurfaceZ (rightTest_);

		float angle_ = Mathf.Tan ((_rightDepth.y - _leftDepth.y) / (_rightDepth.x - _leftDepth.x));

		Quaternion rotation_ = Quaternion.AngleAxis (angle_ * 180.0f / Mathf.PI, Vector3.forward);
		Quaternion counterRotation_ = Quaternion.AngleAxis (Mathf.Sin (angle_ + Time.time * 0.5f) * _rockingAngle, Vector3.left);
		transform.rotation = rotation_ * counterRotation_;

		Vector3 finalPosition_ = _targetPosition; 
		finalPosition_.y = Mathf.Max (_leftDepth.y, _rightDepth.y);
		_targetPosition = finalPosition_;

		transform.position = transform.position + (_targetPosition - transform.position) * _softness;
	}

	void Start(){
		_targetPosition = transform.position;
	}

	void OnDrawGizmos(){
		Gizmos.color = Color.red;
		Gizmos.DrawLine (_leftDepth, _rightDepth);
	}
}
